-- Modern Leaf Utility (Executor-Safe)
-- Style B: Professional Dark Minimal UI
-- Combined with Full Utility Logic

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Task = task
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")

local Player = Players.LocalPlayer
if not Player then
    warn("[ModernLeafUI] LocalPlayer not found. Must run as a LocalScript.")
    return
end
local PlayerGui = Player:WaitForChild("PlayerGui")

-- =========================
-- CONFIG
-- =========================
local ICON_ASSET_ID = "rbxassetid://473950669" -- Replaced with a placeholder icon ID
local WIDTH = 460
local HEIGHT = 380
local ICON_SIZE = 56

local THEME = {
    Background = Color3.fromRGB(18, 18, 20),
    Panel = Color3.fromRGB(24, 26, 30),
    Accent = Color3.fromRGB(86, 137, 255),
    Positive = Color3.fromRGB(80, 200, 120),
    Negative = Color3.fromRGB(255, 85, 85),
    Text = Color3.fromRGB(235, 237, 240),
}

-- =========================
-- STATE & LOGIC CONFIG
-- =========================
local DEFAULT_BATCH_SIZE = 5
local DEFAULT_REBIRTH_COOLDOWN = 60

-- Remotes (Ensure these paths are correct for your game)
local CheckLeavesRemote = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("CheckLeaves")
local UpgradeManagerRemote = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("UpgradeManager")

-- Target container for leaves
local LEAF_SPAWN_CONTAINER = Workspace:WaitForChild("Zones", 10):WaitForChild("1", 10):WaitForChild("LeafSpawns", 10)

-- Leaf Filtering
local VALID_LEAF_NAMES = {
    ["Base"] = true,
    ["Gold"] = true,
    ["Silver"] = true,
    ["Diamond"] = true
}

-- Upgrade Definitions (Display Name -> {ServerString, Args...})
local UPGRADES_LOGIC = {
    SpawnRate = {ServerName = "SpawnRate", Args = {false}},
    LeavesPrice = {ServerName = "LeavesPrice", Args = {false}},
    LeavesAmount = {ServerName = "LeavesAmount", Args = {false}},
    
    ["Rebirth LeavesPrice"] = {ServerName = "LeavesPrice", Args = {false, true}}, 
    ["Rebirth DoubleLeaves"] = {ServerName = "DoubleLeaves", Args = {false}},
    ["Rebirth Radius"] = {ServerName = "Radius", Args = {false}},
}

-- State Variables
local BATCH_SIZE = DEFAULT_BATCH_SIZE
local REBIRTH_COOLDOWN = DEFAULT_REBIRTH_COOLDOWN
local isFarming = false
local farmConnection = nil 
local leavesToHarvest = {}
local rebirthTask = nil
local activeUpgrades = {} -- Tracks active upgrade fire functions
local gamepassFolder = Player:WaitForChild("Gamepass", 10)

-- =========================
-- CALLBACKS (to be set by logic functions)
-- =========================
local CALLBACKS = {
    ToggleFarming = function(enabled) end,
    ToggleGamepassBypass = function(enabled) end,
    ToggleAutoRebirth = function(enabled) end,
    SetBatchSize = function(n) end,
    SetRebirthCooldown = function(n) end,
    ApplyUpgradeToggle = function(name, enabled) end,
}

-- =========================
-- Helpers (GUI functions)
-- =========================
local function new(class, props)
    local obj = Instance.new(class)
    if props then
        for k, v in pairs(props) do
            if k == "Parent" then
                obj.Parent = v
            else
                obj[k] = v
            end
        end
    end
    return obj
end

local function roundCorner(inst, radius)
    local c = Instance.new("UICorner")
    c.CornerRadius = UDim.new(0, radius or 8)
    c.Parent = inst
    return c
end

local function clamp(val, a, b)
    return math.max(a, math.min(b, val))
end

-- Draggable (executor-safe; avoids heavy closures)
local function makeDraggable(frame)
    local dragging = false
    local dragStart = nil
    local startPos = nil

    frame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            dragStart = input.Position
            startPos = frame.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)

    frame.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement then
            -- handled by global InputChanged
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
            local delta = input.Position - dragStart
            frame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        end
    end)
end

local function safeFire(func, ...)
    Task.spawn(function(...)
        local ok, err = pcall(func, ...)
        if not ok then
            warn("[ModernLeafUI] callback error:", err)
        end
    end, ...)
end

-- =========================
-- GUI Creation (from user script)
-- =========================
local screenGui = new("ScreenGui", {Parent = PlayerGui, ResetOnSpawn = false, Name = "ModernLeafUtilityUI"})
local backdrop = new("Frame", {Parent = screenGui, Size = UDim2.new(1,0,1,0), BackgroundTransparency = 1, Name = "Backdrop"})

local main = new("Frame", {
    Parent = screenGui,
    Size = UDim2.new(0, WIDTH, 0, HEIGHT),
    Position = UDim2.new(0.5, -WIDTH/2, 0.5, -HEIGHT/2),
    BackgroundColor3 = THEME.Panel,
    BorderSizePixel = 0,
    Name = "MainWindow",
})
roundCorner(main, 12)

local header = new("Frame", {Parent = main, Size = UDim2.new(1,0,0,56), BackgroundTransparency = 1})

local title = new("TextLabel", {Parent = header, Size = UDim2.new(0.7, -20, 1, 0), Position = UDim2.new(0, 20, 0, 0), BackgroundTransparency = 1, Text = "Leaf Harvester", TextColor3 = THEME.Text, Font = Enum.Font.GothamBold, TextSize = 20, TextXAlignment = Enum.TextXAlignment.Left})

local btnClose = new("TextButton", {Parent = header, Size = UDim2.new(0,36,0,36), Position = UDim2.new(1,-48,0,10), BackgroundColor3 = THEME.Negative, Text = "X", TextColor3 = Color3.new(1,1,1), Font = Enum.Font.GothamBold, TextSize = 18})
roundCorner(btnClose, 8)

local btnMin = new("TextButton", {Parent = header, Size = UDim2.new(0,36,0,36), Position = UDim2.new(1,-96,0,10), BackgroundColor3 = THEME.Accent, Text = "-", TextColor3 = Color3.new(1,1,1), Font = Enum.Font.GothamBold, TextSize = 20})
roundCorner(btnMin, 8)

local content = new("Frame", {Parent = main, Size = UDim2.new(1,0,1,-56), Position = UDim2.new(0,0,0,56), BackgroundTransparency = 1})

local leftPane = new("Frame", {Parent = content, Size = UDim2.new(0.55, -8, 1, 0), Position = UDim2.new(0,4,0,0), BackgroundColor3 = THEME.Background})
roundCorner(leftPane, 10)
leftPane.ClipsDescendants = true

local rightPane = new("Frame", {Parent = content, Size = UDim2.new(0.45, -12, 1, 0), Position = UDim2.new(0.55, 8, 0, 0), BackgroundColor3 = THEME.Panel})
roundCorner(rightPane, 10)

local leftLayout = new("UIListLayout", {Parent = leftPane, Padding = UDim.new(0,12), SortOrder = Enum.SortOrder.LayoutOrder})
leftLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left

-- utility to create labeled row
local function createRow(parent, height)
    local frame = new("Frame", {Parent = parent, Size = UDim2.new(1, -20, 0, height or 44), BackgroundTransparency = 1})
    local label = new("TextLabel", {Parent = frame, Size = UDim2.new(0.6,0,1,0), BackgroundTransparency = 1, TextColor3 = THEME.Text, Font = Enum.Font.Gotham, TextSize = 15, TextXAlignment = Enum.TextXAlignment.Left, Position = UDim2.new(0, 12, 0, 0)})
    local holder = new("Frame", {Parent = frame, Size = UDim2.new(0.4, -20, 1, 0), Position = UDim2.new(0.6, 8, 0, 0), BackgroundTransparency = 1})
    return frame, label, holder
end

-- batch size input
local batchRow, batchLabel, batchHolder = createRow(leftPane, 44)
batchLabel.Text = "Harvest Batch Size"
local batchInput = new("TextBox", {Parent = batchHolder, Size = UDim2.new(1,0,1,0), Text = tostring(DEFAULT_BATCH_SIZE), BackgroundColor3 = Color3.fromRGB(36,40,48), TextColor3 = THEME.Text, Font = Enum.Font.Gotham, TextSize = 14, ClearTextOnFocus = false})
roundCorner(batchInput, 8)

-- rebirth cooldown input
local rebirthRow, rebirthLabel, rebirthHolder = createRow(leftPane, 44)
rebirthLabel.Text = "Rebirth Cooldown (s)"
local rebirthInput = new("TextBox", {Parent = rebirthHolder, Size = UDim2.new(1,0,1,0), Text = tostring(DEFAULT_REBIRTH_COOLDOWN), BackgroundColor3 = Color3.fromRGB(36,40,48), TextColor3 = THEME.Text, Font = Enum.Font.Gotham, TextSize = 14, ClearTextOnFocus = false})
roundCorner(rebirthInput, 8)

-- toggles
local function makeToggle(parent, labelText, default)
    local row, lbl, holder = createRow(parent, 44)
    lbl.Text = labelText
    local btn = new("TextButton", {Parent = holder, Size = UDim2.new(1,0,1,0), BackgroundColor3 = default and THEME.Positive or THEME.Negative, Text = default and "ON" or "OFF", Font = Enum.Font.GothamBold, TextSize = 14, TextColor3 = Color3.new(1,1,1)})
    roundCorner(btn, 8)
    return btn
end

local farmToggle = makeToggle(leftPane, "Auto Farm", false)
local autoRebirthToggle = makeToggle(leftPane, "Auto Rebirth", false)
local gamepassToggle = makeToggle(leftPane, "Gamepass Bypass", false)

-- transparency slider (simplified)
local sliderRow, sliderLabel, sliderHolder = createRow(leftPane, 64)
sliderLabel.Text = "Window Transparency"
local sliderBar = new("Frame", {Parent = sliderHolder, Size = UDim2.new(1,0,0,10), Position = UDim2.new(0,0,0.5,-5), BackgroundColor3 = Color3.fromRGB(38,40,46)})
roundCorner(sliderBar, 6)
local sliderFill = new("Frame", {Parent = sliderBar, Size = UDim2.new(0.12,0,1,0), BackgroundColor3 = THEME.Accent})
roundCorner(sliderFill, 6)
local sliderKnob = new("ImageButton", {Parent = sliderBar, Size = UDim2.new(0,16,0,16), BackgroundTransparency = 1, Position = UDim2.new(0.12, -8, 0.5, -8)})

-- right pane content: upgrades list
local rightLayout = new("UIListLayout", {Parent = rightPane, Padding = UDim.new(0,10), SortOrder = Enum.SortOrder.LayoutOrder})

local upgradeTitle = new("TextLabel", {Parent = rightPane, Size = UDim2.new(1, -24, 0, 28), Position = UDim2.new(0,12,0,12), BackgroundTransparency = 1, Text = "Upgrades", TextColor3 = THEME.Text, Font = Enum.Font.GothamBold, TextSize = 16})

local upgradeNames = {"SpawnRate", "LeavesPrice", "LeavesAmount", "Rebirth LeavesPrice", "Rebirth DoubleLeaves", "Rebirth Radius"}
local upgradeButtons = {}
for i = 1, #upgradeNames do
    local name = upgradeNames[i]
    local y = 12 + 28 + (i-1) * 44
    local btn = new("TextButton", {Parent = rightPane, Size = UDim2.new(1, -24, 0, 34), Text = name .. ": OFF", BackgroundColor3 = Color3.fromRGB(45,50,60), TextColor3 = THEME.Text, Font = Enum.Font.Gotham, TextSize = 14})
    roundCorner(btn, 8)
    upgradeButtons[name] = btn
end

local credits = new("TextLabel", {Parent = rightPane, Size = UDim2.new(1, -24, 0, 60), Position = UDim2.new(0, 12, 1, -72), BackgroundTransparency = 1, Text = "Credits:\nLogic: Gemini/ChatGPT | UI: Dark Minimal", TextColor3 = Color3.fromRGB(180,180,180), Font = Enum.Font.Gotham, TextSize = 12, TextWrapped = true})

-- minimized icon (draggable bubble)
local icon = new("ImageButton", {Parent = screenGui, Size = UDim2.new(0, ICON_SIZE, 0, ICON_SIZE), Position = UDim2.new(0.02, 0, 0.85, 0), BackgroundColor3 = THEME.Panel, Image = ICON_ASSET_ID, AutoButtonColor = false, Name = "MiniIcon"})
roundCorner(icon, 12)
icon.Visible = false

-- make draggable
makeDraggable(main)
makeDraggable(icon)

-- =========================
-- LOGIC IMPLEMENTATION
-- =========================

-- Farming Core Logic
local function handleNewDescendant(descendant)
    if not isFarming or not LEAF_SPAWN_CONTAINER then return end

    if descendant:IsA("BasePart") and VALID_LEAF_NAMES[descendant.Name] then
        table.insert(leavesToHarvest, descendant)
    end
end

local function harvestIfReady()
    if isFarming and #leavesToHarvest >= BATCH_SIZE then
        local batch = {}
        -- Take a batch from the start of the list
        for i = 1, BATCH_SIZE do
            batch[i] = table.remove(leavesToHarvest, 1)
        end
        CheckLeavesRemote:FireServer(batch)
    end
end

-- Auto Rebirth Core Logic
local function autoRebirthLoop()
    while true do
        -- Fire the rebirth upgrade (assuming "RebirthSpawnRate" is the intended action)
        UpgradeManagerRemote:FireServer("RebirthSpawnRate", false) 
        Task.wait(REBIRTH_COOLDOWN)
    end
end

-- Gamepass Logic
local function applyGamepassBypass(enabled)
    if not gamepassFolder then
        warn("Gamepass folder not found on player. Cannot apply bypass.")
        return
    end
    for _, valueObject in ipairs(gamepassFolder:GetChildren()) do
        if valueObject.Value ~= nil then
            valueObject.Value = enabled
        end
    end
end

-- Auto Upgrades Loop (Fires active upgrades every frame)
RunService.Heartbeat:Connect(function()
    harvestIfReady() -- Also handle farming check here
    for _, fireFunc in pairs(activeUpgrades) do
        fireFunc()
    end
end)


-- Define the functions to hook into the CALLBACKS table
local LogicCallbacks = {}

function LogicCallbacks.ToggleFarming(enabled)
    isFarming = enabled
    if enabled and LEAF_SPAWN_CONTAINER then
        farmConnection = LEAF_SPAWN_CONTAINER.DescendantAdded:Connect(handleNewDescendant)
        -- Immediate harvest check for existing leaves
        for _, descendant in ipairs(LEAF_SPAWN_CONTAINER:GetDescendants()) do
            handleNewDescendant(descendant)
        end
    else
        if farmConnection then
            farmConnection:Disconnect()
            farmConnection = nil
        end
        leavesToHarvest = {}
    end
end

function LogicCallbacks.ToggleGamepassBypass(enabled)
    applyGamepassBypass(enabled)
end

function LogicCallbacks.ToggleAutoRebirth(enabled)
    if enabled then
        rebirthTask = Task.spawn(autoRebirthLoop)
    else
        if rebirthTask then
            Task.cancel(rebirthTask)
            rebirthTask = nil
        end
    end
end

function LogicCallbacks.SetBatchSize(n)
    BATCH_SIZE = n
end

function LogicCallbacks.SetRebirthCooldown(n)
    REBIRTH_COOLDOWN = n
    -- No need to restart the Task.spawn, the loop will use the new variable when it waits again
end

function LogicCallbacks.ApplyUpgradeToggle(name, enabled)
    local upgradeData = UPGRADES_LOGIC[name]
    if not upgradeData then return end

    if enabled then
        -- Store a function that fires the remote for this specific upgrade
        activeUpgrades[name] = function()
            UpgradeManagerRemote:FireServer(upgradeData.ServerName, unpack(upgradeData.Args))
        end
    else
        activeUpgrades[name] = nil
    end
end

-- =========================
-- Interaction Logic (GUI Connections)
-- =========================
local isMinimized = false
local function setWindowTransparency(alpha)
    alpha = clamp(alpha, 0, 0.9)
    main.BackgroundTransparency = alpha
    leftPane.BackgroundTransparency = alpha
    rightPane.BackgroundTransparency = alpha
    -- adjust text transparency
    local textAlpha = clamp(1 - alpha * 0.8, 0.35, 1)
    local descendants = main:GetDescendants()
    for i = 1, #descendants do
        local obj = descendants[i]
        if obj:IsA("TextLabel") or obj:IsA("TextButton") or obj:IsA("TextBox") then
            obj.TextTransparency = 1 - textAlpha
        end
    end
end

-- minimize -> animate to icon
local function minimizeToIcon()
    isMinimized = true
    local iconPosXScale = icon.Position.X.Scale
    local iconPosXOffset = icon.Position.X.Offset
    local iconPosYScale = icon.Position.Y.Scale
    local iconPosYOffset = icon.Position.Y.Offset

    local targetXOffset = iconPosXOffset - (WIDTH/2 - ICON_SIZE/2)
    local targetYOffset = iconPosYOffset - (HEIGHT/2 - ICON_SIZE/2)

    local targetPos = UDim2.new(iconPosXScale, targetXOffset, iconPosYScale, targetYOffset)
    local targetSize = UDim2.new(0, ICON_SIZE, 0, ICON_SIZE)

    local tweenInfo = TweenInfo.new(0.26, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut)
    local tweenProps = { Position = targetPos, Size = targetSize, BackgroundTransparency = 1 }
    local tween = TweenService:Create(main, tweenInfo, tweenProps)
    tween:Play()

    Task.wait(0.26)
    if main and main.Parent then
        main.Visible = false
    end
    icon.Visible = true
end

local function restoreFromIcon()
    isMinimized = false
    icon.Visible = false
    main.Visible = true
    -- Restore size and position
    main.Size = UDim2.new(0, WIDTH, 0, HEIGHT)
    main.Position = UDim2.new(0.5, -WIDTH/2, 0.5, -HEIGHT/2) 

    local tweenInfo = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    local tweenProps = { BackgroundTransparency = 0 }
    local tween = TweenService:Create(main, tweenInfo, tweenProps)
    tween:Play()
end

btnMin.MouseButton1Click:Connect(function()
    minimizeToIcon()
end)
icon.MouseButton1Click:Connect(function()
    restoreFromIcon()
end)
btnClose.MouseButton1Click:Connect(function()
    screenGui:Destroy()
end)

-- toggle binding helper
local function bindToggle(btn, cb)
    local state = false
    btn.MouseButton1Click:Connect(function()
        state = not state
        if state then
            btn.BackgroundColor3 = THEME.Positive
            btn.Text = "ON"
        else
            btn.BackgroundColor3 = THEME.Negative
            btn.Text = "OFF"
        end
        safeFire(cb, state)
    end)
    return function() return state end
end

-- Hook Toggles to Logic
local getFarm = bindToggle(farmToggle, LogicCallbacks.ToggleFarming)
local getAutoRebirth = bindToggle(autoRebirthToggle, LogicCallbacks.ToggleAutoRebirth)
local getGamepass = bindToggle(gamepassToggle, LogicCallbacks.ToggleGamepassBypass)

-- slider behavior (executor-safe)
local draggingSlider = false
local function sliderSetFromX(x)
    local absPos = sliderBar.AbsolutePosition
    local absSize = sliderBar.AbsoluteSize
    local rel = clamp((x - absPos.X) / absSize.X, 0, 1)
    sliderFill.Size = UDim2.new(rel, 0, 1, 0)
    sliderKnob.Position = UDim2.new(rel, -8, 0.5, -8)
    local value = 0 + rel * 0.9 -- transparency range 0..0.9
    setWindowTransparency(value)
end

sliderKnob.InputBegan:Connect(function(inp)
    if inp.UserInputType == Enum.UserInputType.MouseButton1 then
        draggingSlider = true
    end
end)
sliderKnob.InputEnded:Connect(function(inp)
    if inp.UserInputType == Enum.UserInputType.MouseButton1 then
        draggingSlider = false
    end
end)
sliderBar.InputBegan:Connect(function(inp)
    if inp.UserInputType == Enum.UserInputType.MouseButton1 then
        sliderSetFromX(inp.Position.X)
        draggingSlider = true
    end
end)
UserInputService.InputChanged:Connect(function(inp)
    if draggingSlider and inp.UserInputType == Enum.UserInputType.MouseMovement then
        sliderSetFromX(inp.Position.X)
    end
end)

-- text inputs
batchInput.FocusLost:Connect(function()
    local n = tonumber(batchInput.Text)
    if n and n >= 1 and n <= 200 then
        n = math.floor(n)
        batchInput.Text = tostring(n)
        safeFire(LogicCallbacks.SetBatchSize, n)
        BATCH_SIZE = n -- Update internal state
    else
        batchInput.Text = tostring(BATCH_SIZE) -- Reset to current value
    end
end)

rebirthInput.FocusLost:Connect(function()
    local n = tonumber(rebirthInput.Text)
    if n and n >= 5 then
        n = math.floor(n)
        rebirthInput.Text = tostring(n)
        safeFire(LogicCallbacks.SetRebirthCooldown, n)
        REBIRTH_COOLDOWN = n -- Update internal state
    else
        rebirthInput.Text = tostring(REBIRTH_COOLDOWN) -- Reset to current value
    end
end)

-- upgrades
for name, btn in pairs(upgradeButtons) do
    local state = false
    btn.MouseButton1Click:Connect(function()
        state = not state
        btn.Text = name .. (state and ": ON" or ": OFF")
        btn.BackgroundColor3 = state and THEME.Positive or Color3.fromRGB(45,50,60)
        safeFire(LogicCallbacks.ApplyUpgradeToggle, name, state)
    end)
end

-- start default transparency
setWindowTransparency(0.12)

-- =========================
-- PUBLIC API 
-- =========================
local API = {}
API.ScreenGui = screenGui
API.Main = main
API.Icon = icon
API.SetCallbacks = function(tbl)
    warn("[ModernLeafUI] Logic is internally set. External calls to SetCallbacks will be ignored.")
end
API.Show = function()
    main.Visible = true
    icon.Visible = false
end
API.Hide = function()
    main.Visible = false
    icon.Visible = true
end

_G.ModernLeafUI = API
print("[ModernLeafUI] Executor-safe GUI loaded with internal logic.")